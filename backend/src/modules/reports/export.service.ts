import { Injectable } from '@nestjs/common';
import PDFDocument from 'pdfkit';
import ExcelJS from 'exceljs';
import { Response } from 'express';

export interface ExportOptions {
    title: string;
    filename: string;
    headers: string[];
    data: any[][];
    metadata?: {
        generatedBy?: string;
        generatedAt?: Date;
        description?: string;
    };
}

@Injectable()
export class ExportService {
    async exportToPDF(options: ExportOptions, res: Response): Promise<void> {
        const doc = new PDFDocument({ margin: 50 });

        // Set response headers
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="${options.filename}.pdf"`);

        // Pipe PDF to response
        doc.pipe(res);

        // Add title
        doc.fontSize(20).text(options.title, { align: 'center' });
        doc.moveDown();

        // Add metadata
        if (options.metadata) {
            doc.fontSize(10);
            if (options.metadata.description) {
                doc.text(`Description: ${options.metadata.description}`);
            }
            if (options.metadata.generatedBy) {
                doc.text(`Generated By: ${options.metadata.generatedBy}`);
            }
            if (options.metadata.generatedAt) {
                doc.text(`Generated At: ${options.metadata.generatedAt.toLocaleString()}`);
            }
            doc.moveDown();
        }

        // Calculate column widths
        const pageWidth = doc.page.width - 100; // Account for margins
        const columnWidth = pageWidth / options.headers.length;

        // Draw table header
        doc.fontSize(10).fillColor('#000');
        let yPosition = doc.y;

        // Header background
        doc.rect(50, yPosition, pageWidth, 25).fillAndStroke('#4A90E2', '#000');

        // Header text
        doc.fillColor('#FFF');
        options.headers.forEach((header, i) => {
            doc.text(header, 50 + i * columnWidth, yPosition + 5, {
                width: columnWidth,
                align: 'left',
            });
        });

        yPosition += 25;
        doc.fillColor('#000');

        // Draw table rows
        options.data.forEach((row, rowIndex) => {
            // Check if we need a new page
            if (yPosition > doc.page.height - 100) {
                doc.addPage();
                yPosition = 50;
            }

            // Alternate row colors
            if (rowIndex % 2 === 0) {
                doc.rect(50, yPosition, pageWidth, 20).fillAndStroke('#F5F5F5', '#DDD');
            } else {
                doc.rect(50, yPosition, pageWidth, 20).stroke('#DDD');
            }

            // Row data
            row.forEach((cell, i) => {
                doc.fillColor('#000').text(String(cell || ''), 50 + i * columnWidth, yPosition + 3, {
                    width: columnWidth,
                    align: 'left',
                });
            });

            yPosition += 20;
        });

        // Add footer
        const pages = doc.bufferedPageRange();
        for (let i = 0; i < pages.count; i++) {
            doc.switchToPage(i);
            doc.fontSize(8).text(
                `Page ${i + 1} of ${pages.count}`,
                50,
                doc.page.height - 50,
                { align: 'center' }
            );
        }

        doc.end();
    }

    async exportToExcel(options: ExportOptions, res: Response): Promise<void> {
        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet(options.title);

        // Set metadata
        workbook.creator = options.metadata?.generatedBy || 'ERP System';
        workbook.created = options.metadata?.generatedAt || new Date();

        // Add title
        worksheet.mergeCells('A1', `${String.fromCharCode(64 + options.headers.length)}1`);
        const titleCell = worksheet.getCell('A1');
        titleCell.value = options.title;
        titleCell.font = { size: 16, bold: true };
        titleCell.alignment = { horizontal: 'center', vertical: 'middle' };
        worksheet.getRow(1).height = 30;

        // Add metadata
        let currentRow = 2;
        if (options.metadata?.description) {
            worksheet.getCell(`A${currentRow}`).value = `Description: ${options.metadata.description}`;
            currentRow++;
        }
        if (options.metadata?.generatedAt) {
            worksheet.getCell(`A${currentRow}`).value = `Generated At: ${options.metadata.generatedAt.toLocaleString()}`;
            currentRow++;
        }
        currentRow++; // Empty row

        // Add headers
        const headerRow = worksheet.getRow(currentRow);
        options.headers.forEach((header, index) => {
            const cell = headerRow.getCell(index + 1);
            cell.value = header;
            cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
            cell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FF4A90E2' },
            };
            cell.alignment = { horizontal: 'left', vertical: 'middle' };
            cell.border = {
                top: { style: 'thin' },
                left: { style: 'thin' },
                bottom: { style: 'thin' },
                right: { style: 'thin' },
            };
        });
        currentRow++;

        // Add data rows
        options.data.forEach((row) => {
            const dataRow = worksheet.getRow(currentRow);
            row.forEach((cell, index) => {
                const excelCell = dataRow.getCell(index + 1);
                excelCell.value = cell;
                excelCell.border = {
                    top: { style: 'thin' },
                    left: { style: 'thin' },
                    bottom: { style: 'thin' },
                    right: { style: 'thin' },
                };

                // Alternate row colors
                if (currentRow % 2 === 0) {
                    excelCell.fill = {
                        type: 'pattern',
                        pattern: 'solid',
                        fgColor: { argb: 'FFF5F5F5' },
                    };
                }
            });
            currentRow++;
        });

        // Auto-fit columns
        worksheet.columns.forEach((column, index) => {
            let maxLength = options.headers[index]?.length || 10;
            options.data.forEach((row) => {
                const cellValue = String(row[index] || '');
                maxLength = Math.max(maxLength, cellValue.length);
            });
            column.width = Math.min(maxLength + 2, 50);
        });

        // Set response headers
        res.setHeader(
            'Content-Type',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        );
        res.setHeader('Content-Disposition', `attachment; filename="${options.filename}.xlsx"`);

        // Write to response
        await workbook.xlsx.write(res);
        res.end();
    }
}
